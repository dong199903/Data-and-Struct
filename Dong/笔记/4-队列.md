# **队列**
董泽平 2019/8/9

#### 如何理解队列？
队列这个概念非常好理解。你可以把它理解成排队买火车票，购票的人只能从队伍的最后面进入，并且每次出去的总是队头的那个。

我们知道栈支持入栈和出栈的操作，和栈类似，队列支持入队和出队操作。最基本的队列有两大类，**顺序队列**和**链式队列**,顺序队列又可以细分为两类，**普通顺序队列**和**循环队列**

接下来，就让我们一一分析这几大类队列吧。



#### 第一类：顺序队列
![](image/queue1.jpg)
看上面的演示，队列头head一直指向队列头a,队尾tail指向的是队列元素的下一个位置
![](image/queue2.jpg)
当调用两次出队操作时，队头head指向了c,队尾不变。
**总结**
我们让队首指针总是指向队列的头(第一个元素),队尾指针总是指向队列的最后元素的下一个。
TIP1.此处的指针在实际代码中并不是指针，就是一个下标的标记，说指针是为了形象
TIP2.队头指针指向队列头，队尾指针为什么要指向最后一个元素的下一个？
     这个不是必要条件，你完全可以自己设置队尾指针指向最后一个元素的。
TIP3.我们还会发现，这种队列存在**"假溢出"**现象,即随着元素的不断出队列，队列前面的空间无法被使用。
	
	//队列的结构体
	struct Queue 
	{
		int front;//队列的头
		int rear;//队列的尾
		int *data;//动态申请内存的数组
	};

#### 第二类：顺序队列(改进版)
![](image/queue3.jpg)
看上图所示，当队列出现假溢出到元素无法入队列，这个时候，我们可以先判断队头指针是否指向了0，队头指针指向了0，证明队列是全满状态，队头指针指向不是0，证明存在假溢出现象，这时，我们可以将数据全部搬移到头部去，并修改队列的头指针和尾指针。

TIP.经过上述的操作，我们实现了空间的高效利用，但是带来了严重的性能问题，因为当发生了假溢出现象时，我们需要做数据搬移，这个时候，入队列的事件复杂度由之前的0(1)改变成了0(n),问题就出在队列的数据搬迁问题上

    //完整的入队操作       
	void Queue_push(struct Queue *q,int data)
	{
		if (q->rear == q->size)
		{
			//队列空间全利用--自动扩容
			if (q->front == 0)
			{
				q->size = 2 * q->size;
				int temp = q->size;
				int *p = (int*)malloc(sizeof(int)*q->size);
				for (int i = 0; i < temp; i++)
				{
					p[i] = q->data[i];
				}
				free(q->data);
				q->data = p;
				q->data[q->rear++] = data;
			}
			//队列空间出现假溢出，数据搬迁至前面
			else {
				int count = 0;
				for (int i = 0; i < (q->rear - q->front); i++)
				{
					q->data[i] = q->data[q->front++];
					count++;
				}
				q->front = 0;
				q->rear = count;
			}
		}
		else {
			q->data[q->rear++] = data;
		}
	}


#### 第三类：顺序队列(终极版本-循环队列)
![](image/queue4.jpg)
循环队列完美解决了上面的两个问题，队列的假溢出现象和数据搬移带来的事件复杂度问题。貌似Linux内核源码都用到了循环队列

TIP1.循环队列不同于前面两类顺序队列的一点是。前面顺序队列的队尾指针可以设计指向队列的尾，也可以设计指向队列的尾部的下一个。但是，循环队列的队尾指针必须设计成指向队列尾部的下一个位置。
具体原因：为了区分队列空和满的条件
q->size是队列的最大存储空间
TIP2.队列空的条件fornt==rear
TIP3.队列满的条件(rear+1)%size = front
TIP4.队列当前元素个数(rear-front+size)%size
TIP5.入队操作rear = (q->rear + 1) % q->size;
TIP6.出对操作q->front = (q->front + 1) % q->size;
TIP7.综上，循环队列存储满时，会空出一个空间没有利用。（为了标记队列是否满）



#### 第四类：链队
![](image/queue5.jpg)
链队就是在链表的基础上模拟的，入队就是将元素添加到链表的尾部，出队列就是删除链表的第一个元素节点。