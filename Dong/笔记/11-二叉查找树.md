## 二叉查找树

1.什么是二叉查找树？
二叉查找树是一种支持数据动态的插入，删除，查找的结构，当让它肯定是依赖二叉树的特性完成的。

2.二叉查找树的设计要求
在树中，任意一个节点的左孩子必须小于这个当前节点，右孩子必须大于当前节点。

3.二叉排序树是如何进行快速查找的？
![](image/tree5.jpg)
我们要查找的数据是19，根据二叉排序树的定义去查找，
首先来到根节点33，大于目标数19，则去左分支找
来到17，小于目标数19，去右分枝找
来到18，小于目标数19，去右分枝找
来到25，大于目标数19，去左分支找
来到19，等于目标数，成功找到。
如果走到某个节点为空，证明查找失败

	//0---没找到
	//1---找到
	void Find_Tree(struct Tree * t, int data)
	{
		struct Tree * p = t;
		while (p != NULL)
		{
			if(data < p->data)
			{
				p = p->left;
			}
			else if(data>p->data){
				p = p->right;
			}
			else
			{
				printf("1\n");
				return;
			}
		}
		printf("0\n");
	}

4.数据的插入
![](image/tree6.jpg)
数据的插入和查找步骤几乎一样，就是多个新建节点和链接。
首先来到33，发现目标55比33大，走右分枝
来到50，发现目标55比50大，走右分枝，
来到58，发现目标55比58小，走左分支，
来到51，发现目标55比51大，走右分枝，
此时为空，就将数据插入该位置。

	void Insert_Tree(struct Tree ** t, int data)
	{
		if ((*t) == NULL)
		{
			(*t) = (struct Tree*)malloc(sizeof(struct Tree));
			(*t)->data = data;
			(*t)->count = 1;
			(*t)->left = NULL;
			(*t)->right = NULL;
		}
		else
		{
			if (data < (*t)->data)
			{
				Insert_Tree(&((*t)->left), data);
			}
			else if (data > (*t)->data)
			{
				Insert_Tree(&((*t)->right), data);
			}
			else
			{
				(*t)->count++;
			}
		}
	}
5.数据的删除
![](image/tree7.jpg)
二叉排序数的删除操作较为复杂（当然记住技巧就简单了）
**二叉排序树的删除操作分为三大类**,分别是目标点无左右孩子，目标点有一个孩子，目标点两个孩子都有。

第一类：目标节点无左右孩子----------**(直接删)**
示例：如图所示，元素55叶子节点，无孩子，我们直接删除就可以

第二类：目标节点存在一个孩子(左孩子或者右孩子)----------**(将对应孩子直接挂在其父元素下)**
示例：如图所示，元素13，存在右孩子，直接将目标元素右孩子挂在其父节点下。

第三类：目标节点两个孩子(左右孩子都在)------------**(先右走一步，一直左走，直到一个没左孩子的节点，将其挂在目标点父元素下)**
示例：如图所示，元素18，先向右走一步，再一直往左走，直到遇见一个没有左孩子的节点为止，此时来到了19，直接将19挂在目标元素的父元素下。


> 网上代码关于删除的，大部分有错误，它们仅仅去释放要删除的节点，但是删除二叉搜索树的实质是链表的删除，要找到前置节点才能正确的删除，否则出现断链的现象。


	/*
	删除操作分三种情况
	
	第一类：该元素无左右孩子，直接删除
	第二类：该元素有左孩子或者右孩子(有一个孩子),直接将该孩子节点与其父节点连接
	第三类：该元素左右孩子都在
	3.1：先向左走一步，一直向右走，直到走到一个叶子节点，将该叶子节点的赋给待删除节点元素。
	3.2：先向右走一步，一直向左走，直到走到一个叶子节点，将该叶子节点的赋给待删除节点元素。
	*/
	void Del(struct Tree ** t)
	{
		//左子树空，右不空
		if ((*t)->left == NULL && (*t)->right!=NULL)
		{
			struct Tree *p;
			p = (*t);
			(*t) = (*t)->right;
			free(p);
		}
		//右子树空，左不空
		if ((*t)->right == NULL && (*t)->left != NULL)
		{
			struct Tree *p;
			p = (*t);
			(*t) = (*t)->left;
			free(p);
		}
		//左右都空
		if ((*t)->right == NULL && (*t)->left != NULL)
		{
			free((*t));
		}
		//左右都不空
		if ((*t)->right != NULL && (*t)->left != NULL)
		{
			//采用左枝法，先向左走一步，一直向右边走
			struct Tree *p,*q;
			p = (*t)->left;
			while (p->right != NULL)
			{
				p = p->right;
			}
			//该节点右子树一定是空，左边不确定
			(*t)->data = p->data;
			if (p->left == NULL)
			{
				free(p);
			}
			else
			{
				q = p;
				p = q->left;
				free(q);
			}
		}
	}
	void Del_Tree(struct Tree ** t, int data)
	{
		if ((*t) == NULL)
		{
			return;
		}
		if ((*t)->data == data)
		{
			Del(t);
		}
		else if ((*t)->data > data)
		{
			Del_Tree(&((*t)->left), data);
		}
		else
		{
			Del_Tree(&((*t)->right), data);
		}
	}

**总结**

二叉查找树，是十分优秀的查找算法，它的查找时间复杂度是0(logn),并且中序遍历二叉查找树，它输出的序列是有序的。