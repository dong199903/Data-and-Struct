## 散列表
1.什么是散列表？
散列表就是通过一个映射函数，把每个数据映射为一个数组下标，按照下标存储起来，当我们访问这个数据时，只需要通过映射函数计算出下标，就可以找到这个数。
2.散列表映射函数
从散列表定义来看，散列表最重要的是设计映射函数，映射函数决定效率和减少地址冲突，常见的映射函数有下面的几个。。。
+ 直接定址法
+ 数学分析法
+ 除留取余法
+ 随机数法

3.散列表的冲突问题
不管我们设计的散列函数多牛逼。都无法避免数据映射冲突问题，冲突就是两个数据经过映射函数处理后得到的数据是一样的。这个时候不可能把它两放一起吧。因此发明了解决地址冲突问题的办法
+ 开放地址法
+ 拉链法
+ 多哈希法

下面我们分析下整个散列表实现过程。
#### 一：开放地址法
1.首先准备大小为10的数组。设计映射函数是除留取余法。
key = data % size
![](image/find2.jpg)

2.假设我们有数据5,4,8,15,6时，对应散列表情况
  首先元素5%10=5,所以找到第5个位置放5，
  接着元素4%10=4,所以找到第4个位置放4,
  接着元素8%10=8,所以找到第8个位置放8,
  接着元素15%10=5,发现5号位置有元素，发生了冲突，采用开放地址法，逐个找后面第一个为空的位置，就是位置6.
  接着元素6%10=6,发现6号位置有了元素，发生了冲突，继续往后找，放在第7个位置上
![](image/find4.jpg)

	//具有自动扩容性的散列表(装载因子最大为0.75时自动扩容)
	Hash_Table_Array::Hash_Table_Array()
	{
		this->maxSize = 10;
		this->data = new int[this->maxSize];
		this->size = 0;
		for (int i = 0; i < this->maxSize; i++)
		{
			this->data[i] = 99999;//标记数组初始值(标空)
		}
	}
	//数据的插入
	void Hash_Table_Array::Insert(int data)
	{
		int *newData,i,index;
		//1.每次插入数据前，先检测是否超过了最大装载因子
		if (this->size*1.0 >= this->maxSize*0.75)
		{
			newData = new int[this->maxSize * 2];
			for (i = 0; i < this->maxSize * 2; i++)
			{
				newData[i] = 99999;
			}
			//将原数据重新映射地址
			for (i = 0; i < this->maxSize;i++)
			{
				
				if (this->data[i] != 99999)
				{
					index = this->data[i] % (2 * this->maxSize);
					while (newData[index] != 99999)
					{
						index = (index + 1) % (2 * this->maxSize);
					}
					newData[index] = this->data[i];
				}
			}
			this->maxSize = 2 * this->maxSize;
			delete[] this->data;
			this->data = newData;
			index = data % this->maxSize;
			//开放地址法
			while (this->data[index] != 99999)
			{
				index = (index + 1) % this->maxSize;
			}
			this->data[index] = data;
			this->size++;
		}
		else {
			index = data % this->maxSize;
			//开放地址法
			while (this->data[index]!=99999)
			{
				index = (index + 1) % this->maxSize;
			}
			this->data[index] = data;
			this->size++;
		}
	}

	//数据的查询
	int Hash_Table_Array::isFind(int data)
	{
		int index,sum=0;
		index = data % this->maxSize;
		//开放地址法
		while (this->data[index] != data)
		{
			index = (index + 1) % this->maxSize;
			sum++;
			//如果继续查找数据为空，或者回到原点，表示该数据不存在
			if (this->data[index] == 99999 || sum == this->maxSize)
			{
				return -1;
			}
		}
		return index;
	}

### 二：链地址法
1.首先同样准备大小为10的边表,设计映射函数是除留取余法
key=data%size
![](image/find3.jpg)
2.假设我们有数据5,4,8,15,6时，对应散列表情况
  首先元素5%10=5,所以链接到第5个边表节点，
  接着元素4%10=4,所以链接到第4个边表节点,
  接着元素8%10=8,所以链接到第8个边表节点,
  接着元素15%10=5,有冲突，直接链接到位置5的链表后面去
  接着元素6%10=6,所以链接到第6个边表节点
![](image/find5.jpg)

	//初始化处理
	Hash_Table_List::Hash_Table_List()
	{
		int i;
		this->len = 0;
		this->length = 10;
		this->head = new Node[10];
		for (i = 0; i < 10; i++)
		{
			this->head[i].data = i;
			this->head[i].next = NULL;
		}
	}


	//插入数据
	void Hash_Table_List::Insert(int data)
	{
		//超过装载因子，自动扩容
		Node *newHead,*p,*q;
		int i,value,index;
		if (this->len*1.0 >= this->length * 0.75)
		{
			newHead = new Node[this->length * 2];
			for (i = 0; i < this->length * 2; i++)
			{
				newHead[i].data = i;
				newHead[i].next = NULL;
			}
			//将旧数据，逐个重新映射到新的散列表上
			for (i = 0; i < this->length; i++)
			{
				p = this->head[i].next;
				while (p)
				{
					//原数据
					value = p->data;
					//映射后地址
					index = p->data % (this->length * 2);
					//根据地址，放到新散列表的后面
					q = new Node;
					q->data = value;
					q->next = newHead[index].next;
					newHead[index].next = q;
					//删除旧散列表边表结构
					this->head[i].next = p->next;
					delete p;
					p = this->head[i].next;
				}
			}
			if (this->head)
			{
				delete[] this->head;
			}
			this->head = newHead;
			this->length = this->length * 2;
	
			//插入数据进去
			index = data % this->length;
			q = new Node;
			q->data = data;
			q->next = this->head[index].next;
			this->head[index].next = q;
			this->len++;
		}
		//没有超过装载因子，不需要扩容
		else
		{
			index = data % this->length;
			q = new Node;
			q->data = data;
			q->next = this->head[index].next;
			this->head[index].next = q;
			this->len++;
		}
	}
	


	//查找处理
	int Hash_Table_List::isFind(int data)
	{
		Node *p;
		int index;
		index = data %this->length;
		p = this->head[index].next;
		while (p != NULL && p->data != data)
		{
			p = p->next;
		}
		if (p == NULL)
		{
			return -1;//没找到
		}
		//返回链表的下标
		else {
			return index;
		}
	}

> 代码的实现不需要太熟悉，思想很高级
