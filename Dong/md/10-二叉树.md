## 二叉树
对于树这块，基础部分都好理解，我仅仅整理树的难点知识


> 我们先想一下，二叉树如何存储？顺序存储还是链式存储？
> 我们尝试用这两种方式都去尝试存储树

#### 1.二叉树的顺序存储

![](image/tree1.jpg)

我们用一个数组去顺序存储二叉树的节点。从数组下标1开始存储是为了方便计算孩子位置
每个节点的左孩子下标=2*当前节点位置， 每个节点的右孩子下标=2*当前节点位置+1
对比上图，很容易看出啦。

![](image/tree2.jpg)
观察这个二叉树，数组很多空间没有被利用，所以顺序存储造成了巨大浪费。我们对比图1，发现，顺序存储适合存储完全二叉树。

#### 2.二叉树的链式存储

![](image/tree3.jpg)
上图就是二叉树的链式存储，我们发现很形象，也很具体的描述了二叉树。
这种存储适合非完全二叉树的存储。


#### 3.二叉树的先序遍历

记住口号：**左中右**
先遍历左孩子，再自己，再右孩子。

	void pre_Order(struct Tree * t)
	{
		if (t == NULL)
		{
			return;
		}
		printf("%c", t->data);
		pre_Order(t->left);
		pre_Order(t->right);
	}
#### 4。二叉树的中序遍历
记住口号：**中左右**
先遍历自己，再左孩子，再右孩子。

	void mid_Order(struct Tree * t)
	{
		if (t == NULL)
		{
			return;
		}
		mid_Order(t->left);
		printf("%c", t->data);
		mid_Order(t->right);
	}
#### 5。二叉树的后序遍历
记住口号：**左右中**
先遍历左孩子，再右孩子，再自己。
	
	void post_Order(struct Tree * t)
	{
		if (t == NULL)
		{
			return;
		}
		mid_Order(t->left);
		mid_Order(t->right);
		printf("%c", t->data);
	}

#### 6.二叉树求高度
	
![](image/tree4.jpg)
观察上图，该树的高度可以递归求得。
...
树高度 = 1 + max(2分支高度,3分支高度);
2分枝高度 = 1 + max(0,4分枝高度);
3分枝高度 = 1 + max(0,5分枝高度);
...
我们可以发现递归公式：某个分枝高度 = 1 + max(左分支高度,右分枝高度);

	int getHigh(struct Tree * t)
	{
		if (t == NULL)
		{
			return 0;
		}
		return getHigh(t->left) > getHigh(t->right) ? getHigh(t->left) + 1 : getHigh(t->right) + 1;
	}

#### 7.二叉树的节点个数
![](image/tree4.jpg)

继续观察图片，发现树节点个数还是可以用递归实现

...
树节点个数和 = 1 + 2分枝总个数 + 3分枝总个数
2分枝总个数 = 1 + 0 + 4分枝总个数
3分枝总个数 = 1 + 0 + 5分枝总个数
...

递归公式：节点个数 = 1 + 左分支节点数 +右分枝节点数

	int getCount(struct Tree * t)
	{
		if (t == NULL)
		{
			return 0;
		}
		else
		{
			return getCount(t->left) + getCount(t->right) + 1;
		}
	}